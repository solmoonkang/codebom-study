# *Socket* 이란?

---

간단하게 말하자면, 소켓은 네트워크 상에서 데이터를 주고받는 통로라고 볼 수 있다.

즉, 클라이언트와 서버 간의 통신을 가능하도록 하며, 이를 인터넷 소켓이라고 부르기도 한다.

네트워크 통신을 하려면 각 TCP / IP 계층의 협력을 통해서 이루어진다.

소켓은 그 중 전송 계층과 응용 계층 사이에 있는 인터페이스로 즉, 통신의 시작점과 종료점이 된다.

- 이를 엔드포인트라고 하며, 엔드포인트는 아이피 주소와 포트 번호의 조합을 의미한다.
- 따라서, 모든 TCP 연결은 두 개의 엔드포인트로 유일하게 식별될 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c33fee58-8f40-4523-b222-c56099de30a9/90773e02-3dbd-4657-881d-12f45587ef5a/Untitled.png)

---

<aside>
👀 **소켓이 하는 일**

1. 소프트웨어와 소프트웨어를 연결한다.
    - IP와 서비스 포트를 통해 찾아서 연결한다.

2. 소프트웨어 간 데이터를 통신한다.
    - 인터넷에서 소켓을 찾아 연결하고 데이터를 송수신한다.

</aside>

## *Socket* 구성 요소

---

소켓의 구성 요소는 프로토콜, IP 주소, 포트 번호가 있다.

1. 프로토콜: 네트워크 통신에서 데이터를 어떻게 주고받을지에 대한 규약이다. 대표적으로 TCP와 UDP가 있다.
    1. TCP: 신뢰성 있는 연결을 보장하며, 데이터 전송의 순서를 보장한다.
        - 데이터 경계의 구분이 없는 바이트 스트림(Byte-Stream) 서비스이다.
    2. UDP: 연결 설정 없이 데이터를 빠르게 전송하지만, 데이터 전송의 순서나 도착을 보장하지 않는다.
        - 데이터 경계를 구분하는 데이터그램(Datagram) 서비스이다.
2. IP 주소: 인터넷에 연결된 각 장치는 고유한 IP 주소를 가지고 있다. 즉, 장치를 고유하게 식별하는 주소이다.
3. 포트 번호: 한 장치 내에서 실행 중인 특정 프로그램을 식별하는 번호이다.

## Socket 프로그래밍

---

프로세스 간 통신에 사용되는 소켓을 이용한 통신 프로그래밍을 소켓 프로그래밍이라고 한다.

- 소켓 프로그래밍은 ‘서버 소켓(Server Socket)’과 ‘클라이언트 소켓(Client Socket)’으로 구분된다.
- 또한, 소켓 프로그래밍에서는 동기와 비동기 방식을 선택할 수 있다.

### 동기와 비동기 소켓

**[ 동기 소켓, Blocking ]**

---

- 동기 소켓은 작업이 완료될 때까지 프로그램이 대기 상태가 되어 다른 작업을 수행할 수 없다.
- 동기 방식은 구현이 간단하지만, 대기 시간 동안 프로그램이 멈춰 있으므로 효율적이지 않을 수 있다.

**[ 비동기 소켓, Non-Blocking ]**

---

- 비동기 소켓은 작업이 완료되는 동안에도 프로그램이 다른 작업을 수행할 수 있다.
- 반면 비동기 방식은 복잡하지만, 대기 시간 동안에도 다른 작업을 수행할 수 있어 효율적이다.

### 서버와 클라이언트 소켓

**[ 서버 소켓, Server Socket ]**

---

서버 소켓은 서버에서 운영되며, 클라이언트의 연결 요청을 기다리는 역할을 한다.

- 주로 특정 포트에 바인드되어 있어, 해당 포트를 통해 들어오는 연결 요청을 대기하고 있다.
- 연결 요청이 들어오면 새로운 소켓을 생성하여 클라이언트와의 통신 채널을 열게 된다.

**[ 클라이언트 소켓, Client Socket ]**

---

클라이언트 소켓은 클라이언트에서 운영되며, 서버에 연결을 요청하는 역할을 한다.

- 클라이언트 소켓은 서버의 IP 주소와 포트 번호를 알고 있어야 하며, 이를 통해 서버에 연결을 요청한다.

이렇게 서버 소켓과 클라이언트 소켓이 각각 역할을 수행함으로써 네트워크 상에서 데이터의 송수신이 이뤄진다.

<aside>
👀 예를 들어, 전화 통화를 생각해보자.

전화를 걸기 위한 전화기(클라이언트 소켓)와 전화를 받기 위한 전화기(서버 소켓)가 필요한 것과
비슷한 원리이다.

</aside>

## Socket API 실행 흐름

---

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c33fee58-8f40-4523-b222-c56099de30a9/91cb115d-5544-40ea-9784-e2e8ff398902/Untitled.png)

### 클라이언트 소켓의 흐름

---

<aside>
📌 **[ Blocking Client Socket ]**: *소켓 생성 → 연결 요청 → 데이터 송수신 → 소켓 닫기*

</aside>

---

1. **클라이언트 소켓 생성**: *socket( )*
    1. 연결 대상에 대한 정보가 들어있지 않은 소켓(아무 것도 들어있지 않는 빈 소켓)을 생성한다.
    2. 이때, 소켓의 종류를 지정한다.
        - TCP 소켓을 위해 Stream 타입을,
        - UDP 소켓을 위해 Datagram 타입으로 지정이 가능하다.
2. **연결 요청**: *connect( )*
    1. 연결하고 싶은 대상에게 “연결해줘 !” 라고 요청을 전송한다.
    2. 자세하게 말하면, IP 주소와 서비스 포트 번호로 연결하고 싶은 타겟(대상)을 지정한다.
        - 여기서 IP와 포트는 서버 소켓 측의 IP와 포트를 의미한다.
    3. 단, 요청을 보냈다고 끝나는 것이 아닌, 그 요청에 대한 결과가 돌아와야지 Connect의 실행이 끝난다.
3. **데이터 송수신**: *read( ) / write( )*
    1. 클라이언트와 서버 간에 정보를 주고받는 과정을 의미한다.
    2. 연결 요청이 성공하면 클라이언트 소켓과 서버 소켓 사이에는 통신 채널이 열리게 된다.
    3. 단, 송신은 데이터를 보내는 것이기 때문에 데이터를 언제 얼마나 보낼 것인지 알 수 있지만,
       수신은 상대방이 언제, 얼만큼의 데이터를 보낼 것인지 알 수 없다는 차이점이 존재한다.
        - 따라서, 수신하는 API는 별도의 Thread에서 진행하게 된다.
4. **소켓 닫기**: *close( )*
    1. 더 이상의 데이터 송수신이 없다고 판단되면 소켓을 닫는다.

### 서버 소켓의 흐름

---

<aside>
📌 **[ Blocking Server Socket ]**: 
*소켓 생성 → 바인딩 → 연결 요청 대기 → 연결 수립 → 데이터 송수신 → 소켓 닫기*

</aside>

---

1. **서버 소켓 생성**: *socket( )*
    1. 클라이언트 소켓과 마찬가지로 연결 대상에 대한 정보가 들어있지 않은 빈 소켓을 생성한다.
        - 서버 소켓은 리스닝 소켓과 연결 소켓 두 종류의 소켓을 관리하게 된다.
        - 처음 서버가 생성한 빈 소켓은 리스닝 소켓으로 클라이언트의 연결 요청을 기다리는 것이다.
            - 리스닝 소켓 자체는 데이터를 주고받는 역할을 하지 않는다.
2. **바인딩**: *bind( )*
    1. 우리가 컴퓨터를 사용할 때 매우 많은 서비스를 이용하는데 이는 수많은 프로세스가 동시에 작업한다.

   만약, 서버 소켓이 받은 데이터를 다시 보내줄 때 프로세스들의 포트번호가 동일하면 혼란이 생긴다.
   따라서 서버 소켓이 고유한 포트 번호를 만들 수 있도록 소켓과 포트번호를 결합해줘야 한다.
   - 이러한 문제를 해결하기 위해 운영체제에서 내부적으로 포트 번호와 소켓 연결 정보를 관리한다.
   - 참고로, 하나의 프로세스는 동일한 포트 번호를 가진 여러 소켓을 결합할 수 있다.
   - 우리가 하나의 채팅 앱을 사용하더라도 동시에 많은 사람들과 채팅을 할 수 있는 이유이다.
3. **클라이언트 연결 요청 대기**: *listen( )*
    1. 서버 소켓에서 포트번호와 bind( ) 작업을 마치면 클라이언트로부터 연결 요청을 받을 준비가 된 것이다.
    2. 클라이언트가 연결 요청을 할 때까지 기다리다가 연결 요청이 오면 대기 상태를 종료하고 반환한다.
4. **클라이언트 연결 수립**: *accept( )*
    1. 클라이언트의 연결 요청이 들어오면, 서버는 이 요청을 수락하고 새로운 연결 소켓을 생성한다.
        - 연결 소켓은 클라이언트와 실질적으로 데이터를 주고 받는 소켓이다.
5. **데이터 송수신**: *read( ) / write( )*
    1. 클라이언트 데이터 송수신과 마찬가지로, 서버와 클라이언트 간 데이터를 주고받는 과정이다.
6. **소켓 닫기**: *close( )*
    1. 서버 소켓의 종류에 따라 소켓을 닫는 시점과 방법이 다르다.
        - 리스닝 소켓은 서버 프로그램이 종료되는 시점에 소켓을 닫으며,
        - 연결 소켓은 각각의 클라이언트와의 통신이 종료될 때 소켓을 닫는다.