## 🗂️ INDEX 란?

---

INDEX란 추가적인 쓰기 작업과 저장 공간을 활용하여 DB 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

예를 들어, 책에서 원하는 내용을 찾는다고 할 때, 책의 모든 페이지를 찾아 보는 것은 오랜 시간이 걸린다.

그렇기 때문에 책의 저자들이 책의 맨 앞 혹은 맨 뒤에 색인을 추가하는데, 이는 DB의 인덱스와 동일하다.

따라서 인덱스는 DB에서 모든 테이블의 데이터를 검색하면 오랜 시간이 걸리기 때문에, 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 한다.

### INDEX 종류

인덱스의 종류는 크게 클러스터형 인덱스와 보조 인덱스로 나뉘는데, 각 인덱스의 특징은 다음과 같다.

**[ 클러스터형 인덱스, Clustered INDEX ]**

---

클러스터형 인덱스는 테이블당 1개만 존재할 수 있다.

클러스터형 인덱스 기본 키로 지정된 컬럼은 자동으로 클러스터링 인덱스가 생성된다.

클러스터형 인덱스는 실제 저장된 데이터와 같은 무리의 페이지 구조를 가지고 있다.

클러스터링 인덱스를 기준으로 데이터가 자동으로 정렬된다.

- 기본 키를 변경하면 클러스터링 인덱스가 변경되서, 변경된 기본 키를 기준으로 다시 자동 정렬한다.

**[ 보조 인덱스, Secondary INDEX OR Non-Clustered INDEX ]**

---

보조 인덱스는 클러스터형 인덱스와 반대로, 한 테이블에 여러 개의 설정이 가능하다.

보조 인덱스 생성 방법은 UNIQUE 키워드로 고유 컬럼을 지정할 경우 자동으로 보조 인덱스가 생성된다.

보조 인덱스는 실제 저장된 데이터와 다른 무리의 별도의 페이지 구조를 가지고 있다.

보조 인덱스는 클러스터링 인덱스와 반대로 데이터를 정렬하지 않는다.

또한, CREATE INDEX 문으로 직접 보조 인덱스 생성이 가능하다.

## 📼 INDEX 사용 이유

---

DB 테이블의 데이터는 순서 없이 쌓이게 되므로 특정 조건의 데이터를 찾으려면 테이블의 모든 데이터에 접근하여 비교하는 과정이 필요하다.

만약, SELECT 문을 사용하여 원하는 조건의 데이터를 검색할 때, 저장된 데이터의 양이 엄청나게 많다면 검색을 위한 순회에 많은 자원과 시간이 소모될 것이다.

이때, 인덱스가 있을 경우 SEARCH-KEY가 정렬되어 있기 때문에 조건 검색 시 속도가 빠르다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c33fee58-8f40-4523-b222-c56099de30a9/ea99d916-1850-4afe-9958-e11d6bce22c5/Untitled.png)

---

자주 조회되는 컬럼에 대한 인덱스 테이블을 따로 만들어서 SELECT 문이 들어왔을 때, 인덱스 테이블에 있는 값들로 결과 값을 조회해 온다.

때문에 대량의 데이터를 가지고 있고 SELECT ~ WHERE 같은 특정 조건의 데이터를 찾을 때, 인덱스를 활용하여 빠르게 데이터를 가져올 수 있다.

- 반대로 데이터의 양이 많지 않다면 굳이 인덱스를 사용할 이유가 없어진다.

추가로, 인덱스를 활용하면 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능 또한 향상된다.

UPDATE와 DELETE 연산을 수행하기 위해서는 해당 대상을 조회해야 하는 작업을 해야 할 수도 있기 때문이다.

```sql
// SOLMOON이라는 이름을 UPDATE하기 위해서는 SOL을 조회해야 한다.
UPDATE USER SET NAME = 'SOLMOON' WHERE NAME = 'SOL';
```

## 🎥 INDEX 동작 과정

---

인덱스를 통해서 테이블에 있는 데이터를 찾는 동작 과정은 다음과 같다.

1. 먼저, 인덱스 테이블에서 WHERE 절에 포함된 값을 검색한다.
2. 그리고 해당 값의 TABLE_ID의 PK를 획득한다.
3. 마지막으로 가져온 TABLE_ID의 PK로 원본 테이블에서 값을 조회한다.

## 🌳 B+ Tree 알고리즘

---

DBMS는 인덱스를 다양한 알고리즘으로 관리하는데, 일반적으로 사용되는 알고리즘은 B+ Tree 알고리즘이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c33fee58-8f40-4523-b222-c56099de30a9/f43c66e7-b00c-4f0f-aa41-805c1f53453f/Untitled.png)

---

B+ Tree 구조는 2개의 자식만을 갖는 이진 트리를 확장한 N개의 자식을 가질 수 있는 알고리즘이다.

하지만 이진 트리는 자식 간의 좌우 균형이 맞지 않을 경우 매우 비효율적이다.

- 때문에 B+ Tree 항상 균형을 맞춘다는 의미에서 균형 트리(Balanced Tree)라고도 부른다.

B+ Tree는 다음과 같은 구조로 구성되어 있다.

- 경로의 출발점이 되는 루트 노드(ROOT NODE)
- 리프노드까지의 경로 역할을 하는 논-리프 노드(NON-LEAF NODES)
- 실제 데이터가 저장된 리프 노드(LEAF NODES)

이러한 B+ Tree는 리프 노드에 이르기까지 자식 노드에 포인터가 저장되어 있다.

즉, B+ Tree의 검색은 루트 노드에서 어떤 리프 노드에 이르는 한 개의 경로만을 검색해서 매우 효율적이다.

Hash Table이 아닌, B+ Tree 구조를 사용하는 이유는 다음과 같다.

---

- Hash Table과 비교했을 때, SELECT 절의 질의 조건에 `<`, `>` (부등호 연산)이 포함되어 있다.
- Hash Table은 `=` (동등 연산)에 특화된 자료구조로, 부등호 연산을 사용할 경우 문제가 발생할 수 있다.

## ⚠️ INDEX 사용 시 주의 사항

---

1. 인덱스는 **테이블의 형태**로 관리가 된다.

   즉, 자원을 계속해서 소모한다는 의미로, 무분별한 인덱스 사용은 성능에 부정적인 영향을 미칠 수 있다.


2. 또한, 인덱스는 **이진트리를 사용**하기 때문에 기본적으로 **정렬**이 되어 있다.

   이로 인해 검색과 조회의 속도를 향상시킬 수는 있지만, 잦은 데이터의 변경(삽입, 수정, 삭제)이 이루어지면,

   인덱스 테이블을 변경하고 정렬하는데 드는 오버헤드로 인해서 오히려 성능 저하가 발생할 수 있다.

   **INSERT**: 입력 순서대로 저장되지만, 인덱스 테이블에 정렬을 해서 저장해서 성능 저하가 발생한다.

   **DELETE**: 테이블에서만 삭제되고, 인덱스 테이블에는 남아있어서 쿼리의 수행 속도가 저하된다.

   **UPDATE**: 인덱스에는 UPDATE가 없어서, DELETE, INSERT 작업 수행 시 부하가 발생한다.


3. 데이터의 중복이 높은 컬럼(카디널리티가 낮은 컬럼)은 인덱스로 만들어도 소용이 없다.

4. 다중 컬럼을 인덱싱할 때, **카디널리티가 높은 컬럼에서 낮은 컬럼 순서**로 인덱싱해야 효율적이다.
