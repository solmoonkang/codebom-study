## 🔙 트랜잭션

### 트랜잭션이란?

---

트랜잭션은 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 논리적 단위이다.

- 상태를 변화시킨다는 말은 *SELECT, INSERT, UPDATE* 등과 같은 조작어를 사용하는 행동을 의미한다.
- 트랜잭션은 상황에 따라 여러 개가 만들어질 수 있고, 각각의 트랜잭션들은 상황에 따라서 **Commit(저장)** 혹은 **Rollback(철회)** 될 수 있다.
    - ***커밋(Commit)***: 모든 부분 작업이 정상적으로 완료되면, 해당 변경사항을 한 번에 DB에 반영한다.
    - ***롤백(Rollback)***: 부분 작업이 실패하면, 트랜잭션 실행 전으로 되돌린다.

예를 들어, 사용자 A가 사용자 B에게 10,000원을 송금한다고 생각해보자.

1. 사용자 A의 계좌에서 만원을 차감한다: *UPDATE*를 통해 사용자 A의 잔고 변경
2. 사용자 B의 계좌에서 만원을 추가한다: *UPDATE*를 통해 사용자 B의 잔고 변경

⇒ 이를 통틀어서 하나의 ***“트랜잭션”*** 이라고 한다. (두 쿼리문 모두 완료되어야만 하나의 작업 완료)

또 다른 예를 들어, ATM에서 계좌이체를 한다고 생각해보자.

1. A 은행에서 출금을 해서 B 은행으로 송금하려고 한다.
2. 송금 도중 알 수 없는 이유로 A 은행 계좌에서 돈은 빠져나갔지만, B 은행의 계좌에 입금되지 않았다.
3. 위와 같은 상황을 막기 위해 거래가 성공적으로 끝나야만, 이를 완전한 거래라고 승인한다.
    - 때문에, 거래 도중 오류가 발생했을 때는 해당 거래는 처음부터 없었던 거래로 완전히 되돌린다.

데이터베이스 테이블에서 데이터를 읽은 후 다른 테이블에 데이터를 입력, 갱신, 삭제를 처리한다.

- 이때, 처리 도중 오류가 발생하면 “Rollback” 을 하게 되고,
- 모든 처리 과정이 성공적으로 수행되었을 경우는 최종적으로 “Commit” 을 하게 된다.

⇒ 이처럼 거래의 안전성을 확보하는 방법도 “트랜잭션” 이라고 한다.

### 트랜잭션의 성질

---

트랜잭션에는 4가지 성질(**Atomicity, Consitency, Isolation, Durability → ACID**)이 있다.

**[ 원자성 - Atomicity ]**

---

- 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장한다.
- 즉, 트랜잭션이 데이터베이스에 모두 반영되거나 혹은 전혀 반영되지 않아야 한다. (All or Nothing)

원자성은 트랜잭션에 의해 변경된 내역을 유지하면서, 이전에 커밋된 상태를 임시 영역에 저장함으로써 보장한다.

- 수행하고 있는 트랜잭션에서 오류가 발생하면 현재 내역을 없애고 임시 영역에 저장된 상태로 롤백한다.
- 여기서 이전 데이터들이 임시로 저장되는 영역을 “롤백 세그먼트” 라고 한다.
    - 롤백 세그먼트는 수정되기 전의 파일, 블록 ID 같은 블록 정보 및 데이터들을 저장한다.

- 현재 수행하고 있는 트랜잭션에 의해 새롭게 변경되는 내역을 데이터베이스 테이블이라고 한다.
- 만약, 오류가 발생하면 롤백을 하는데, 확실하게 오류가 발생하지 않은 부분도 다시 작업을 해야 한다.

이를 해결하기 위해 확실한 부분이 롤백되지 않도록 중간 저장인 Sava Point를 지정하여 해결한다.

1. 일반적으로 롤백을 명시하면, INSERT, DELETE 등의 작업 전체가 취소된다.
2. SAVEPOINT를 사용하면 전체가 아닌 특정 부분에서 트랜잭션을 취소시킬 수 있다.
3. 취소하려는 지점을 SAVEPOINT로 명시한 뒤, ROLLBACK TO SAVEPOINT를 실행하면,
    - 해당 SAVEPOINT 지점까지 처리한 작업이 ROLLBACK 된다.

**[ 일관성 - Constency ]**

---

- 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다.
- 예를 들어, 작성 테이블의 본문 내용의 글자 제한이 255자 라고 가정하자.
    - 트랜잭션이 일어나면 글자 제한 조건을 만족해야만 트랜잭션이 수행되고, 위반하면 거부해야 한다.
- 즉, 트랜잭션 수행 전, 후에 데이터 모델의 모든 제약 조건(기본키, 외래키, 도메인 등)을 만족해야 한다.

트랜잭션에서 일관성 보장은 어떤 이벤트와 조건이 발생했을 때, 트리거, Trigger를 통해 보장한다.

트리거는 특정 테이블에 INSERT, DELETE와 같은 DML문이 수행되었을 때, 자동으로 동작하는 프로그램이다.

- 사용자가 직접 호출하는 것이 아닌 데이터베이스에서 자동적으로 호출하는 것이 특징이다.
- 따라서, 트리거를 통해 일관성이 보장될 수 있다.
- 예를 들어, 한쪽의 데이터베이스 테이블 정보의 수정이 일어났을 경우, 다른 쪽의 테이블에서도 함께 정보가 수정될 수 있도록 명시적으로 자동 업데이트를 하는 명령 등을 구성하게 된다.

**[ 격리성, 고립성 - Isolation ]**

---

- 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장해야 한다.
- 즉, 둘 이상의 트랜잭션이 동시에 병행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연상에 끼어들 수 없다.

이러한 격리성을 보장하기 위해서 Lock & Unlock 기법을 사용한다.

- 데이터를 읽거나 쓰는 작업 중일 때, 해당 영역에 Lock을 걸어 다른 트랜잭션이 접근하지 못하도록 하고,
- 먼저 들어온 트랜잭션의 요청이 끝나면 Unlock 하여 다른 트랜잭션이 처리될 수 있도록 허용한다.
- 만약, Lock과 Unlock을 잘못 사용하면 어떠한 트랜잭션도 수행할 수 없는 Deadlock 상태에 빠질 수 있다.

**[ 지속성, 영속성 - Durability ]**

---

- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.
- 즉, 트랜잭션이 성공적으로 종료되어 커밋 연산을 실행하면, 해당 데이터는 DB에 영원히 반영되어야 한다.