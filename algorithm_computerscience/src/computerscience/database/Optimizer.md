## 🛞 Optimizer(옵티마이저)란?

---

<aside>
📌 옵티마이저란 가장 효율적인 방법으로 SQL 수행 시 최적의 경로를 생성해주는 DBMS 핵심 엔진이다.

</aside>

즉, 개발자가 작성한 SQL을 실행하면, DBMS는 옵티마이저를 기반으로 실행 계획을 세워서 쿼리를 실행한다.

### 쿼리 실행 절차

---

그렇다면, 개발자가 작성한 SQL이 어떻게 실행되고, 어떻게 옵티마이저가 적용되는지 살펴보면 다음과 같다.

쿼리의 실행 절차를 나누게 되면, 다음과 같이 4단계의 단계로 나눌 수 있다.

> **Parsing → Optimization → Generation → Execution**
>

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c33fee58-8f40-4523-b222-c56099de30a9/2b6f711f-9e46-41eb-80fe-1838643092a4/Untitled.png)

---

1. **SQL Parsing**:
    1. DBMS는 개발자가 세운 실행 계획을 쪼개서 SQL 파서를 통해 옵티마이저로 파싱한다.
    2. 즉, 개발자가 전송한 SQL을 쪼개서 구성요소를 파악하고, 이를 파싱해서 파싱트리를 만든다.
    3. 대부분의 SQL 문장의 문법적인 검사는 파싱 단계에서 이루어진다.
        - SQL 문법이 잘못되었다면 해당 단계에서 걸리지게 되며, 정상이라면 SQL 파싱 트리가 만들어진다.

1. **Optimization**:
    1. 파싱 단계에서 만들어진 SQL 파싱 트리를 기반으로 옵티마이저가 가진 여러 동작을 수행한다.

    - **Query Transformer**:
        - 파싱된 SQL을 보고 같은 결과를 도출하되, 좀 더 나은 실행 계획을 갖는 SQL로 변환이 가능한지를 판단하여 변환 작업을 수행한다.
        - 이때, 불필요한 조건을 제거하거나 복잡한 연산을 단순화시키는 등의 작업을 수행한다.
    - **Estimator**:
        - 시스템 통계 정보를 딕셔너리로부터 수집하여 SQL을 실행할 때 소요되는 총 비용을 계산한다.
    - **Plan Generator**:
        - Estimator를 통해 계산된 값들을 토대로 후보군이 되는 실행 계획을 도출한다.

1. **Generation**:
    1. 옵티마이저가 생성한 실행 계획을 SQL 엔진이 실제 수행할 수 있는 코드나 프로시저 형태로 포맷한다.

1. **Execution**:
    1. 포맷팅된 SQL을 실행하고, 결과를 사용자에게 전달한다.

## 🎞️ 옵티마이저의 종류

---

옵티마이저는 최적화를 기반으로 기준을 나누는 **“규칙 기반 옵티마이저”**와 **“비용 기반 옵티마이저”**가 있다.

### RBO: Rule-Based Optimizer(규칙 기반 옵티마이저)

---

<aside>
📌 RBO는 실행 계획을 결정할 때 미리 정해둔 규칙에 따라서 쿼리를 최적화하는 방식이다.

</aside>

---

RBO는 쿼리 실행 계획을 만들 때 일반적으로 사용되는 JOIN, WHERE 등의 SQL에 대한 고정 규칙을 적용한다.

일반적으로 규칙을 세울 때 실행 속도가 빠른 순으로 규칙을 세워 우선 순위가 높은 방법을 채택한다.

- 규칙이란 액세스 경로별 우선 순위로 인덱스 구조, 연산, 조건절 형태가 순위를 결정 짓는 주요인이다.

DBMS에서 제공하는 RBO의 경우, 대부분의 규칙 우선순위를 사용자가 변경할 수 없다.

- 그러나 일부 DBMS에서는 사용자가 규칙의 우선순위를 변경할 수 있는 설정을 제공하기도 한다.

다음은 DBMS에서 제공하는 일반적으로 고정된 RBO의 우선순위는 다음과 같다.

| 우선순위 | 항목 |
| --- | --- |
| 1 | ROWID를 사용한 단일 행인 경우 |
| 2 | 클러스터 조인에 의한 단일 행인 경우 |
| 3 | 유일하거나 기본키(Primary Key)를 가진 해시 클러스터 키에 의한 단일 행인 경우 |
| 4 | 유일하거나 기본키(Primary Key)에 의한 단일 행인 경우 |
| 5 | 클러스터 조인인 경우 |
| 6 | 해시 클러스터 조인인 경우 |
| 7 | 인덱스 클러스터 키인 경우 |
| 8 | 복합 칼럼 인덱스인 경우 |
| 9 | 단일 칼럼 인덱스인 경우 |
| 10 | 인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우 |
| 11 | 인덱스가 구성된 칼럼에서 무제한 범위를 검색하는 경우 |
| 12 | 정렬-병합(Sort-Merge) 조인인 경우 |
| 13 | 인덱스가 구성된 칼럼에서 MAX 혹은 MIN을 구하는 경우 |
| 14 | 인덱스가 구성된 칼럼에서 ORDER BY를 실행하는 경우 |
| 15 | 전체 테이블을 스캔(FULL TABLE SCAN)하는 경우 |

### CBO: Cost-Based Optimizer(비용 기반 옵티마이저)

---

<aside>
📌 CBO는 실행 계획을 선택하기 위해 쿼리를 수행하는데 소요되는 시간을 기반으로 최적화하는 방식이다.

</aside>

---

CBO는 실행 계획을 최대 2천 개까지 세운 뒤 비용이 최소한으로 나온 실행 계획을 수행하게 된다.

이때, 실행 계획을 수립 시 판단 기준이 되는 비용은 예상치이다.

- CBO는 비용 예측을 위해 테이블, 인덱스, 컬럼 등의 객체 통계 정보 및 시스템 통계 정보를 이용한다.

통계 정보가 없는 경우 비효율적 실행 계획을 생성할 수 있기 때문에, 정확한 통계 정보를 유지하는 것이 중요하다.

## 🤼‍♂️ RBO vs CBO

---

| 항목 | 규칙 기반 옵티마이저 | 비용 기반 옵티마이저 |
| --- | --- | --- |
| 개념 | 사전에 정의된 규칙 기반 | 최소비용 계산 실행계획 수립 |
| 기준 | 실행우선 순위(Ranking) | 액세스 비용(Cost) |
| 인덱스 | 인덱스 존재 시 가장 우선시 사용 | Cost에 의한 결정 |
| 성능 | 사용자 SQL작성 숙련도 | 옵티마이저 예측 성능 |
| 장점 | 판단이 매우 규칙적 실행 예상 가능 | 통계 정보를 통한 현실 요소 적용 |
| 단점 | 예측 통계정보 요소 무시 | 최소 성능 보장 계획의 예측 제어 어려움 |
| 사례 | AND 중심 양쪽 ‘=’ 시 Index Merge 사용 | AND 중심 양쪽 ‘=’ 시 분포도별 Index 선택 |

## 💨 옵티마이저에 영향을 미치는 요소

---

**[ SQL과 연산자의 형태 ]**

- 결과가 같더라도 SQL을 어떤 형태로 작성했는지,
- 또는 어떤 연산자를 사용했는지에 따라 옵티마이저가 다른 선택을 할 수 있다.

**[ 옵티마이징 팩터 ]**

- 쿼리를 똑같이 작성하더라도 인덱스, IOT, 클러스터링, 파티셔닝 등을 어떻게 구성했는지에 따라
- 실행 계획과 성능이 크게 달라진다.

**[ DBMS 제약 설정 ]**

- 개체, 참조, 도메인 무결성 등을 위해 DBMS가 제공하는 PK, FK 등과 같은 제약 기능을 이용할 수 있고,
- 이러한 제약 설정은 옵티마이저가 쿼리 성능을 최적화하는 데 매우 중요한 정보를 제공한다.

**[ 옵티마이저 힌트 ]**

- 옵티마이저의 판단보다 사용자가 지정한 옵티마이저 힌트가 우선된다.

**[ 통계 정보 ]**

- 통계 정보가 옵티마이저에게 미치는 영향력은 절대적이다.
- CBO의 모든 판단 기준은 통계 정보를 통해서 나온다.

주요 통계 정보들에는 다음과 같은 것들이 있다.

| 구분 | 세부 통계 정보 |
|------|----------------|
| 테이블 | - 테이블의 전체 행의 개수 <br> - 테이블이 차지하고 있는 전체 블록 개수 <br> - 테이블의 행들이 가지고 있는 평균 길이 |
| 컬럼 | - 컬럼 값의 종류 <br> - 컬럼 내부 NULL 값의 분포도 <br> - 컬럼 값의 평균 길이 <br> - 컬럼 내부 데이터 분포의 추정치 |
| 인덱스 | - LEAF BLOCK 수 : 데이터를 보관하는 블록 수 <br> - LEVELS : 인덱스 트리의 LEVEL 정보 <br> - CLUSTERING FACTOR : 접근하고자 하는 데이터가 모여 있는 밀집도 |
| 시스템 통계 정보 | - I/O 성능 및 사용률 <br> - CPU 성능 및 사용률 |


**[ 옵티마이저 관련 파라미터 ]**

- SQL, 데이터, 통계 정보, 하드웨어 등 모든 환경이 동일하더라도 DBMS 버전을 업그레이드하면 옵티마이저가 다르게 동작할 수 있다.
- 이는 옵티마이저 관련 파라미터가 추가 또는 변경되면서 나타나는 현상이다.

**[ DBMS 버전과 종류 ]**

- 옵티마이저 관련 파라미터가 같더라도 버전에 따라 실행 계획이 다를 수 있다.
- 또한 같은 SQL이라도 DBMS 종류에 따라 내부적으로 처리하는 방식이 다를 수 있다.